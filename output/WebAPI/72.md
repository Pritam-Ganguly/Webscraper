# How to Implement Redis Cache in ASP.NET Core

Back to: [ASP.NET Core Web API Tutorials](https://dotnettutorials.net/course/asp-net-core-web-api-tutorials/)

## **How to Implement Redis Cache in ASP.NET Core Web API**

In this article, I will discuss **how to Implement a Redis Cache in an ASP.NET Core Web API** Application with Examples. Please read our previous articles on [**Customizing In-Memory Cache in ASP.NET Core Web API**](https://dotnettutorials.net/lesson/how-to-create-custom-in-memory-cache-in-asp-net-core-web-api/) Applications with Examples.

##### **What is Distributed Caching in ASP.NET Core?**

Distributed caching is a caching mechanism that shares cache data across multiple server instances. This type of caching is crucial in environments where applications are deployed in a load-balanced server farm or across multiple servers. It helps maintain data consistency and improves the performance and scalability of applications by providing a fast way of accessing frequently used data from a shared cache, reducing the load on the database server.

##### **Distributed Caching Architecture:**

Let’s first understand the architecture of Distributed Caching, and then we will see how to implement Distributed caching using Redis cache in our ASP.NET Core Web API Application. To understand the architecture of Distributed Caching, please look at the following diagram.

![Distributed Caching Architecture](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%221036%22%20height=%22541%22%3E%3C/svg%3E "Distributed Caching Architecture")

##### **Components of the Distributed Caching Architecture:**

**Users:** The users are the clients or consumers who send requests to the application.

**Load Balancer:** The Load Balancer is responsible for distributing incoming requests across multiple instances of the application servers to ensure no single server is overloaded with too many requests. This helps to maintain high availability and distribute workload evenly.

**App Servers:**  These are instances of the application server responsible for processing incoming requests and serving data. They connect to the distributed cache to retrieve or store data. Multiple app servers allow the system to handle a higher volume of concurrent requests, ensuring scalability.

**Distributed Cache:**  The distributed cache is a shared cache that multiple application servers can use to retrieve data quickly. Unlike in-memory caching, which is local to an application server, distributed cache is a centralized cache available to all application servers. This allows all application servers to share and retrieve cached data, which results in faster response times.

**Database:** The database stores the persistent data. Whenever a request cannot be served from the distributed cache (i.e., there is a cache miss), the application server queries the database to fetch the data.

##### **How Distributed Caching Works:**

- **User Request:** Users send requests, which are first directed to the Load Balancer.
- **Load Balancer:** The load balancer routes the request to one of the App Servers. This could be done using various algorithms like round-robin, least connections, etc.
- **Cache Check (Cache Hit or Miss):** The App Server tries to find the requested data in the Distributed Cache. If the requested data is found in the cache, it is called a Cache Hit. In a cache hit, the data is retrieved directly from the cache and returned to the user very fast.
- **Cache Miss:** If the data is not found in the cache, it is called a Cache Miss. In this case, the App Server queries the Database to retrieve the data.
- **Store Data in Cache:** Once the data is fetched from the database, the App Server stores the data in the Distributed Cache for future requests. Storing this data in the distributed cache reduces future access times if the same data is requested again.
- **Return Data:** Whether the requested data comes from the cache or the database, it is sent back to the user via the App Server.

**Use Cases:** Distributed Caching is often used in high-traffic applications like e-commerce websites, social media platforms, or any system where data is frequently read and changed infrequently (e.g., product details, user profile information, etc.).

##### **Advantages of Distributed Caching:**

- **Reduced Load on Database:** By storing and serving the frequently accessed data from the distributed cache, the Database is relieved from frequently being queried for the same information repeatedly, reducing database load and improving performance.
- **Improved Scalability:** Multiple App Servers can use the Distributed Cache concurrently, which helps scale the application horizontally. As traffic increases, more app servers can be added, and they can all benefit from the centralized cached data.
- **Faster Response Time:** Fetching data from a cache is significantly faster than querying a database, reducing response times and improving the user experience.

##### **What is Redis?**

Redis is an open-source, in-memory data structure store that serves as a database, cache, and message broker. In the context of ASP.NET Core Web API, Redis is commonly used as a caching layer (distributed caching solution) to improve application performance by storing frequently accessed data in memory, thus reducing the need to access the data from slower storage mediums like Databases, or External APIs.

It is the first-choice caching solution among ASP.NET Core developers due to its high speed, scalability, and support for advanced data structures.

##### **Setting up Redis on Windows 10/11**

Redis is primarily designed to run on Linux, macOS, and BSD systems. Officially, it doesn’t support Windows. However, developers can use alternative methods to run Redis on Windows machines. Ideally, developers use a secondary machine (mostly Linux) that handles caching, where Redis runs and serves as a cache memory for multiple applications. Let us proceed and see how we can set up Redis on a Windows 10/11 machine:

##### **Download Redis for Windows:**

Please visit the following GitHub URL to download a Windows-compatible version of Redis supported by Microsoft:

[**https://github.com/microsoftarchive/redis/releases/tag/win-3.0.504**](https://github.com/microsoftarchive/redis/releases/tag/win-3.0.504)

Once you visit the above URL, it will open the GitHub repo below. Download the **Redis-x64-3.0.504.zip** file from this page on your machine, as shown below.

![Setting up Redis on Windows 10/11](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%221266%22%20height=%22623%22%3E%3C/svg%3E "Setting up Redis on Windows 10/11")

Once you click on the above Redis-x64-3.0.504.zip file, it will download the ZIP folder, then extract the Zip Folder to a preferred location on your machine, and you should see the following:

![How to Implement Redis Cache in ASP.NET Core Web API](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%22656%22%20height=%22600%22%3E%3C/svg%3E "How to Implement Redis Cache in ASP.NET Core Web API")

##### **Start the Redis Server:**

Navigate to the extracted folder and double-click on redis-server.exe to start the Redis server. A console window will open, indicating that Redis is running on port 6379, as shown in the image below. Keep this window open to ensure the Redis server continues running. Please observe the port number (**6379**) on which Redis is running, which we will use in our ASP.NET Core Application.

![How to Implement Redis Cache in ASP.NET Core Web API Application with Examples](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%221095%22%20height=%22542%22%3E%3C/svg%3E "How to Implement Redis Cache in ASP.NET Core Web API Application with Examples")

##### **Test the Redis Server:**

Let’s check if the Redis server is up and accessible. Redis also supports CLI commands, and using the CLI command, we can quickly test whether the Redis cache is working fine or not. To do so, go to the Redis Zip Extracted folder and double-click the Redis-cli.exe file, which will open the following Redis CLI window. Using this window, we can access the Redis. To test if the server is up and running, enter the command PING. You should receive a PONG response indicating that the server is alive, as shown in the image below. This is a simple test to see if the server is alive.

![How to Implement Redis Cache in ASP.NET Core Web API Application](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%22415%22%20height=%22133%22%3E%3C/svg%3E "How to Implement Redis Cache in ASP.NET Core Web API Application")

##### **Basic Redis Commands:**

The following are some of the Basic Commands:

- **Set a Value: SET Country “India”**
- **Get a Value: GET Country**
- **Delete a Key: DEL Country**

Now, we can use the SET command to set a new Key-Value based cache item. In the example below, I used the key Country and the value of India. We can use the GET command with the cache key to retrieve the cache value. Similarly, you need to use the DEL command to delete the cache key.

![How to Implement Redis Cache in ASP.NET Core Web API](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%22450%22%20height=%22216%22%3E%3C/svg%3E "How to Implement Redis Cache in ASP.NET Core Web API")

##### **Integrating Redis Cache in ASP.NET Core Web API:**

Imagine we have an e-commerce website where users frequently access product information. Instead of querying the database for each request for product details, the data can be cached in the distributed cache. When a user requests product details, the application server can directly fetch the data from the cache, thus providing a faster response.

Let’s see how to implement Redis Cache in an ASP.NET Core Application. I will create a simple ASP.NET Core Web API project that uses Entity Framework Core to query and return Products from the SQL Server database.

##### **Project Setup:**

First, create a new ASP.NET Core Web API project named **RedisCachingDemo.** Once you create the project, we need to add the following Packages for Entity Framework Core to work with the SQL Server database. You can install these packages using the following commands in the Package Manager Console.

- **Install-Package Microsoft.EntityFrameworkCore.SqlServer**
- **Install-Package Microsoft.EntityFrameworkCore.Tools**

##### **Define the Database Model and DbContext**

In our example, we need to fetch the product master data. First, create a new folder named **Models**. Inside the **Models** folder, create a class file named **Product.cs,** and then copy and paste the following code.

```
namespace RedisCachingDemo.Models
{
    public class Product
    {
        public int Id { get; set; }
        public string? Name { get; set; }
        public string? Category { get; set; }
        public int Price { get; set; }
        public int Quantity { get; set; }
    }
}
```

##### **Create DbContext:**

Next, we need to create the DbContent class. First, create a new folder named **Data**. Inside the Data folder, create a class file named **ApplicationDbContext.cs** and then copy and paste the following code. Here, we are also inserting some dummy data for testing purposes.

```
using Microsoft.EntityFrameworkCore;
using RedisCachingDemo.Models;
using System;

namespace RedisCachingDemo.Data
{
    public class ApplicationDbContext : DbContext
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
            : base(options)
        {
        }

        public DbSet<Product> Products { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            // Generate dummy data
            var products = GenerateDummyProducts(1000);

            // Seed data into Products table
            modelBuilder.Entity<Product>().HasData(products);
        }

        private static Product[] GenerateDummyProducts(int count)
        {
            var random = new Random();
            var products = new Product[count];

            for (int i = 1; i <= count; i++)
            {
                // Generate a random product name
                var name = $"Product {i}";

                // Randomly assign a category
                var category = random.Next(0, 3) switch
                {
                    0 => "Fruits",
                    1 => "Vegetables",
                    _ => "Beverages"
                };

                // Generate a random price between 10 and 1000
                var price = random.Next(10, 1001);

                // Generate a random quantity between 10 and 200
                var quantity = random.Next(10, 201);

                products[i - 1] = new Product
                {
                    Id = i, // Ensure unique Id for seed data
                    Name = name,
                    Category = category,
                    Price = price,
                    Quantity = quantity
                };
            }

            return products;
        }
    }
}
```

##### **Configure Connection String:**

Next, we need to add the connection string in the appsettings.json file. So, modify the appsettings.json file as follows. Here, the Entity Framework Core will create the database named ProductsDB if it has not already been created in the SQL server.

```
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=LAPTOP-6P5NK25R\\SQLSERVER2022DEV;Database=ProductsDB;Trusted_Connection=True;TrustServerCertificate=True;"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}
```

##### **Configure the DbContext in the Program.cs:**

Please add the following line to the **Program.cs** class file to configure DbContext.

```
// Configure DbContext with SQL Server
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));
```

##### **Create Database Migration:**

Open the Package Manager Console and execute the **Add-Migration** command to create a new Migration file. Then, execute the **Update-Database** command to apply the migration to the database.

![Create Database Migration](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%22862%22%20height=%22312%22%3E%3C/svg%3E "Create Database Migration")

Once you execute the above command, it should create the **ProductsDB** database with the Products table, as shown in the below image:

![Create Database Migration](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%22366%22%20height=%22356%22%3E%3C/svg%3E "Create Database Migration")

##### **ProductController**

Create a new API Empty controller named **ProductsController** inside the Controllers folder and then copy and paste the following code.

```
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using RedisCachingDemo.Data;

namespace RedisCachingDemo.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class ProductsController : ControllerBase
    {
        private readonly ApplicationDbContext _context;

        public ProductsController(ApplicationDbContext context)
        {
            _context = context;
        }

        [HttpGet("all")]
        public async Task<IActionResult> GetAll()
        {
            var products = await _context.Products.AsNoTracking().ToListAsync();

            return Ok(products);
        }

        [HttpGet("Category")]
        public async Task<IActionResult> GetProductByCategory(string Category)
        {
            var products = await _context.Products.Where(prd => prd.Category.ToLower() == Category.ToLower()).AsNoTracking().ToListAsync();

            return Ok(products);
        }
    }
}
```

##### **Testing the API endpoint:**

Open Postman or any other API testing tool, access the above API endpoint and notice the time it takes to return data. The following screenshot shows that it took 1033 milliseconds when I tested the API without using any caching mechanism.

![Testing the API endpoint](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%221037%22%20height=%22567%22%3E%3C/svg%3E "Testing the API endpoint")

##### **Integrating Redis Cache in ASP.NET Core Web API**

Let us proceed and see how we can integrate the Redis cache into our ASP.NET Core Web API Project. To connect and start caching data from .NET Core applications with Redis cache, we need to install **Microsoft.Extensions.Caching.StackExchangeRedis** package. You can also install the Package using the Package Manager Console by executing the following command:

- **Install-Package Microsoft.Extensions.Caching.StackExchangeRedis**

##### **Configure Redis in appsettings.json**

Next, we need to add the Redis connection string to the **appsettings.json** file. Please modify the file as follows. Please remember that 6379 is the Port number on which our Redis Server is running.

```
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=LAPTOP-6P5NK25R\\SQLSERVER2022DEV;Database=ProductsDB;Trusted_Connection=True;TrustServerCertificate=True;"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "RedisCacheOptions": {
    "Configuration": "localhost:6379",
    "InstanceName": "RedisCachingDemo"
  },
  "AllowedHosts": "*"
}
```

##### **RedisCacheOptions**

This is the section or key under which all Redis-related configurations are specified. We can name this section anything.

##### **“Configuration”: “localhost:6379”**

This key specifies the connection string for the Redis server. Here, **localhost** is the host where the Redis server is running. **localhost** also indicates that Redis is running on the same machine your application runs. If Redis were hosted elsewhere, we need to specify that server’s IP address or hostname. **6379** is the port number on which the Redis server will listen for incoming connections.

###### **“InstanceName”: “RedisCachingDemo”**

The InstanceName is a prefix used for all entries created by the instance of our application. This can be useful when multiple applications use the same Redis server, and we want to avoid key collisions and make it easier to identify which ones belong to which application. In this case, every key stored in Redis by this application will be prefixed with RedisCachingDemo.

##### **Setup Redis in Program.cs**

Next, we need to configure our application to support Redis cache, and for this purpose, we need to register the **AddStackExchangeRedisCache** service. So, please modify the Program class as follows. The following code is self-explained, so please read the comment lines for a better understanding.

```
using Microsoft.EntityFrameworkCore;
using RedisCachingDemo.Data;

namespace RedisCachingDemo
{
    public class Program
    {
        public static void Main(string[] args)
        {
            var builder = WebApplication.CreateBuilder(args);

            // Add services to the container.

            // Configure DbContext with SQL Server
            builder.Services.AddDbContext<ApplicationDbContext>(options =>
                options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

            // Adding Redis service
            // It adds and configures Redis distributed cache service 
            builder.Services.AddStackExchangeRedisCache(options =>
            {
                //This property is set to specify the connection string for Redis
                //The value is fetched from the application's configuration system, i.e., appsettings.json file
                options.Configuration = builder.Configuration["RedisCacheOptions:Configuration"];

                //This property helps in setting a logical name for the Redis cache instance. 
                //The value is also fetched from the appsettings.json file
                options.InstanceName = builder.Configuration["RedisCacheOptions:InstanceName"];
            });

            builder.Services.AddControllers();
            // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
            builder.Services.AddEndpointsApiExplorer();
            builder.Services.AddSwaggerGen();

            var app = builder.Build();

            // Configure the HTTP request pipeline.
            if (app.Environment.IsDevelopment())
            {
                app.UseSwagger();
                app.UseSwaggerUI();
            }

            app.UseHttpsRedirection();

            app.UseAuthorization();

            app.MapControllers();

            app.Run();
        }
    }
}
```

##### **How to Use Redis for Cache in ASP.NET Core:**

Once the Redis server settings are configured in the Program class, we can inject the Redis cache into our controllers or services and use it to cache data. To do so, we need to inject the IDistributedCache instance into our controllers or services to interact with Redis. The following are the primary methods provided by the IDistributedCache, which we can use to manage the cache data:

- **Get(string key):** This method synchronously retrieves the cached item as a byte array using the provided key. If the key is not found, it returns null.
- **GetAsync(string key):** Asynchronously retrieves the cached item as a byte array using the provided key. Like its synchronous counterpart, it returns null if the key is not found.
- **Set(string key, byte[] value, DistributedCacheEntryOptions options):** Synchronously sets the specified key to the byte array value with the provided cache entry options, which can include settings such as expiration times.
- **SetAsync(string key, byte[] value, DistributedCacheEntryOptions options):** Asynchronously sets the specified key to the byte array value with the provided cache entry options.
- **Remove(string key):** Synchronously removes a cache entry by key.
- **RemoveAsync(string key):** Asynchronously removes a cache entry by key.

##### **Using Redis Cache in Controller:**

For a better understanding, please modify the Products Controller as follows:

```
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Caching.Distributed;
using RedisCachingDemo.Data;
using RedisCachingDemo.Models;
using System.Text.Json;

namespace RedisCachingDemo.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class ProductsController : ControllerBase
    {
        private readonly ApplicationDbContext _context;
        private readonly IDistributedCache _cache;

        public ProductsController(ApplicationDbContext context, IDistributedCache cache)
        {
            _context = context;
            _cache = cache;
        }

        [HttpGet("all")]
        public async Task<IActionResult> GetAll()
        {
            var cacheKey = "GET_ALL_PRODUCTS";
            List<Product> products;

            try
            {
                // Get data from cache
                var cachedData = await _cache.GetStringAsync(cacheKey);
                if (cachedData != null)
                {
                    // Deserialize cached data
                    products = JsonSerializer.Deserialize<List<Product>>(cachedData) ?? new List<Product>();
                }
                else
                {
                    // Fetch data from database
                    products = await _context.Products.AsNoTracking().ToListAsync();

                    if(products != null)
                    {
                        // Serialize data and cache it
                        var serializedData = JsonSerializer.Serialize(products);

                        var cacheOptions = new DistributedCacheEntryOptions()
                            .SetSlidingExpiration(TimeSpan.FromMinutes(5));

                        await _cache.SetStringAsync(cacheKey, serializedData, cacheOptions);
                    }
                }

                return Ok(products);
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { message = "An error occurred while retrieving products.", details = ex.Message });
            }
        }

        [HttpGet("Category")]
        public async Task<IActionResult> GetProductByCategory(string Category)
        {
            var cacheKey = $"PRODUCTS_{Category}";
            List<Product> products;

            try
            {
                // Get data from cache
                var cachedData = await _cache.GetStringAsync(cacheKey);
                if (cachedData != null)
                {
                    // Deserialize cached data
                    products = JsonSerializer.Deserialize<List<Product>>(cachedData) ?? new List<Product>();
                }
                else
                {
                    // Fetch data from database
                    products = await _context.Products.Where(prd => prd.Category.ToLower() == Category.ToLower()).AsNoTracking().ToListAsync();

                    if (products != null)
                    {
                        // Serialize data and cache it
                        var serializedData = JsonSerializer.Serialize(products);

                        var cacheOptions = new DistributedCacheEntryOptions()
                            .SetAbsoluteExpiration(TimeSpan.FromMinutes(5));

                        await _cache.SetStringAsync(cacheKey, serializedData, cacheOptions);
                    }
                }

                return Ok(products);
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { message = "An error occurred while retrieving products.", details = ex.Message });
            }
        }
    }
}
```

##### **Testing**

Run the application and test that the Redis Cache is working as expected. Let’s try to access the API endpoint once again in Postman. The first request will take slightly longer to execute, but subsequent requests will improve the response time considerably. It came down to just 5 milliseconds, which is quite impressive.

![Redis Cache in ASP.NET Core](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%221016%22%20height=%22567%22%3E%3C/svg%3E "Redis Cache in ASP.NET Core")

##### **How to Update and Delete Redis Cache key in ASP.NET Core**

In ASP.NET Core, updating and deleting Redis cache entries is straightforward. Please modify the Products Controller as follows, which shows updating and deleting cache keys.

```
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Caching.Distributed;
using RedisCachingDemo.Data;
using RedisCachingDemo.Models;
using System.Text.Json;

namespace RedisCachingDemo.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class ProductsController : ControllerBase
    {
        private readonly ApplicationDbContext _context;
        private readonly IDistributedCache _cache;

        public ProductsController(ApplicationDbContext context, IDistributedCache cache)
        {
            _context = context;
            _cache = cache;
        }

        // GET: api/products/all
        [HttpGet("all")]
        public async Task<IActionResult> GetAll()
        {
            var cacheKey = "GET_ALL_PRODUCTS";
            List<Product> products;

            try
            {
                // Attempt to retrieve data from cache
                var cachedData = await _cache.GetStringAsync(cacheKey);
                if (!string.IsNullOrEmpty(cachedData))
                {
                    products = JsonSerializer.Deserialize<List<Product>>(cachedData) ?? new List<Product>();
                }
                else
                {
                    // If not found in cache, fetch from database
                    products = await _context.Products.ToListAsync();

                    if (products != null)
                    {
                        // Cache the data
                        var serializedData = JsonSerializer.Serialize(products);
                        var cacheOptions = new DistributedCacheEntryOptions()
                            .SetSlidingExpiration(TimeSpan.FromMinutes(5));

                        await _cache.SetStringAsync(cacheKey, serializedData, cacheOptions);
                    }
                }

                return Ok(products);
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { message = "An error occurred while retrieving products.", details = ex.Message });
            }
        }

        // GET: api/products/{id}
        [HttpGet("{id}")]
        public async Task<IActionResult> GetProduct(int id)
        {
            var cacheKey = $"Product_{id}";
            Product? product;

            try
            {
                // Attempt to retrieve data from cache
                var cachedData = await _cache.GetStringAsync(cacheKey);
                if (!string.IsNullOrEmpty(cachedData))
                {
                    product = JsonSerializer.Deserialize<Product>(cachedData) ?? new Product();
                }
                else
                {
                    // Fetch data from database if not found in cache
                    product = await _context.Products.FindAsync(id);
                    if (product == null)
                        return NotFound($"Product with ID {id} not found.");

                    // Cache the product data
                    var serializedData = JsonSerializer.Serialize(product);

                    //var cacheOprions = new DistributedCacheEntryOptions
                    //{
                    //    SlidingExpiration = TimeSpan.FromMinutes(5)
                    //};

                    await _cache.SetStringAsync(cacheKey, serializedData, new DistributedCacheEntryOptions
                    {
                        SlidingExpiration = TimeSpan.FromMinutes(5)
                    });
                }

                return Ok(product);
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { message = "An error occurred while retrieving the product.", details = ex.Message });
            }
        }

        // PUT: api/products/{id}
        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateProduct(int id, [FromBody] Product updatedProduct)
        {
            if (id != updatedProduct.Id)
            {
                return BadRequest("Product ID mismatch.");
            }

            try
            {
                var existingProduct = await _context.Products.FindAsync(id);
                if (existingProduct == null)
                    return NotFound($"Product with ID {id} not found.");

                // Update product in database
                _context.Entry(existingProduct).CurrentValues.SetValues(updatedProduct);
                //existingProduct.Name = updatedProduct.Name;
                //existingProduct.Price = updatedProduct.Price;
                //existingProduct.Category = updatedProduct.Category;
                //existingProduct.Quantity = updatedProduct.Quantity;
                await _context.SaveChangesAsync();

                // Update product in cache
                var cacheKey = $"Product_{id}";
                var serializedData = JsonSerializer.Serialize(updatedProduct);
                await _cache.SetStringAsync(cacheKey, serializedData, new DistributedCacheEntryOptions
                {
                    SlidingExpiration = TimeSpan.FromMinutes(5)
                });

                return Ok();
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { message = "An error occurred while updating the product.", details = ex.Message });
            }
        }

        // DELETE: api/products/{id}
        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteProduct(int id)
        {
            try
            {
                var product = await _context.Products.FindAsync(id);
                if (product == null)
                    return NotFound($"Product with ID {id} not found.");

                // Delete product from database
                _context.Products.Remove(product);
                await _context.SaveChangesAsync();

                // Remove product from cache
                var cacheKey = $"Product_{id}";
                await _cache.RemoveAsync(cacheKey);

                return Ok();
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { message = "An error occurred while deleting the product.", details = ex.Message });
            }
        }
    }
}
```

Now, run the application and test the API Endpoints, and it should work as expected.

##### **Managing Redis Cache Data:**

Now, we want to implement the following functionalities:

- **Retrieve All Cached Keys and Values:** Useful for debugging and monitoring cache usage to ensure efficient use of Redis.
- **Retrieve a Specific Cache Entry by Key:** Helps retrieve data directly for validation or manual processing.
- **Clear All Cache Entries:** Used for application resets, significant updates, or cache invalidation scenarios.
- **Clear a Specific Cache Entry:** Essential for maintaining cache consistency when only specific data changes.

Let us create a Cache Controller demonstrating how to interact with the Redis cache for the specified operations. So, create an API Empty Controller named **RedisCacheController** and copy and paste the following code. The following code is self-explained, so please read the comment lines for a better understanding.

```
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Distributed;
using StackExchange.Redis;

namespace RedisCachingDemo.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class RedisCacheController : ControllerBase
    {
        // Dependency for interacting with Redis via IDistributedCache
        private readonly IDistributedCache _distributedCache;

        // Dependency for interacting directly with Redis using StackExchange.Redis
        private readonly IConnectionMultiplexer _redisConnection;

        private readonly IConfiguration _configuration;

        // Constructor for injecting dependencies
        public RedisCacheController(IDistributedCache distributedCache, IConnectionMultiplexer redisConnection, IConfiguration configuration)
        {
            _distributedCache = distributedCache;
            _redisConnection = redisConnection;
            _configuration = configuration;
        }

        [HttpGet("all")]
        public async Task<IActionResult> GetAllCachedKeysAndValues()
        {
            try
            {
                // Get the Redis server instance from the connection multiplexer
                var server = _redisConnection.GetServer(_redisConnection.GetEndPoints().First());

                // Retrieve all keys from the Redis database
                var keys = server.Keys().ToArray();

                // Get the InstanceName from the configuration (as specified in appsettings.json)
                string instanceName = _configuration["RedisCacheOptions:InstanceName"] ?? string.Empty;

                // Initialize a list to store key-value pairs from the cache
                var cacheEntries = new List<KeyValuePair<string, string>>();

                // Iterate over each key and retrieve its value
                foreach (var key in keys)
                {
                    // Remove the instance name prefix if it exists
                    var keyWithoutPrefix = key.ToString().Replace($"{instanceName}", "");

                    // Get the value associated with the current key from the distributed cache
                    var value = await _distributedCache.GetStringAsync(keyWithoutPrefix);

                    // Add the key-value pair to the list; if value is null, set it to "null"
                    cacheEntries.Add(new KeyValuePair<string, string>(keyWithoutPrefix, value ?? "null"));
                }

                // Return the list of key-value pairs as a JSON response
                return Ok(cacheEntries);
            }
            catch (Exception ex)
            {
                // Handle any errors and return a 500 Internal Server Error response
                return StatusCode(500, new { message = "Failed to retrieve cache entries.", error = ex.Message });
            }
        }

        // Retrieve a specific cache entry by its key.
        [HttpGet("{key}")]
        public async Task<IActionResult> GetCacheEntryByKey(string key)
        {
            try
            {
                // Attempt to retrieve the value associated with the provided key asynchronously
                var value = await _distributedCache.GetStringAsync(key);

                // If the key is not found in the cache, return a 404 Not Found response
                if (value == null)
                {
                    return NotFound(new { message = "Cache entry not found." });
                }

                // Return the key-value pair as a JSON response
                return Ok(new { Key = key, Value = value });
            }
            catch (Exception ex)
            {
                // Handle any errors and return a 500 Internal Server Error response
                return StatusCode(500, new { message = "Failed to retrieve cache entry.", error = ex.Message });
            }
        }

        // Clear all cache entries from Redis.
        [HttpDelete("all")]
        public IActionResult ClearAllCacheEntries()
        {
            try
            {
                // Get the Redis server instance from the connection multiplexer
                var server = _redisConnection.GetServer(_redisConnection.GetEndPoints().First());

                // Iterate over all keys in the Redis database
                foreach (var key in server.Keys())
                {
                    // Get the InstanceName from the configuration (as specified in appsettings.json)
                    string instanceName = _configuration["RedisCacheOptions:InstanceName"] ?? string.Empty;

                    // Remove the instance name prefix if it exists
                    var keyWithoutPrefix = key.ToString().Replace($"{instanceName}:", "");

                    // Remove each key-value pair from the distributed cache
                    _distributedCache.Remove(keyWithoutPrefix);
                }

                // Return a success message
                return Ok(new { message = "All cache entries cleared." });
            }
            catch (Exception ex)
            {
                // Handle any errors and return a 500 Internal Server Error response
                return StatusCode(500, new { message = "Failed to clear cache entries.", error = ex.Message });
            }
        }

        // Clear a specific cache entry by its key.
        [HttpDelete("{key}")]
        public async Task<IActionResult> ClearCacheEntryByKey(string key)
        {
            try
            {
                // Remove the cache entry associated with the provided key asynchronously
                await _distributedCache.RemoveAsync(key);

                // Return a success message indicating the specific cache entry was cleared
                return Ok(new { message = $"Cache entry '{key}' cleared." });
            }
            catch (Exception ex)
            {
                // Handle any errors and return a 500 Internal Server Error response
                return StatusCode(500, new { message = "Failed to clear cache entry.", error = ex.Message });
            }
        }
    }
}
```

##### **Registering IConnectionMultiplexer in Program class:**

Next, please modify the Program class as follows to IConnectionMultiplexer to the dependency injection container:

```
using Microsoft.EntityFrameworkCore;
using RedisCachingDemo.Data;
using StackExchange.Redis;

namespace RedisCachingDemo
{
    public class Program
    {
        public static void Main(string[] args)
        {
            var builder = WebApplication.CreateBuilder(args);
            // Add services to the container.

            // Configure the application's DbContext to use SQL Server
            builder.Services.AddDbContext<ApplicationDbContext>(options =>
                // Specify the connection string for the SQL Server database
                options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

            // Add Redis distributed caching service
            builder.Services.AddStackExchangeRedisCache(options =>
            {
                // Specify the Redis server configuration
                // The "Configuration" value is fetched from the appsettings.json file
                // Example format: "localhost:6379" (host and port of the Redis server)
                options.Configuration = builder.Configuration["RedisCacheOptions:Configuration"];

                // Set an instance name for the Redis cache entries
                // This acts as a prefix for keys created by this application in Redis
                options.InstanceName = builder.Configuration["RedisCacheOptions:InstanceName"];
            });

            // Register the Redis connection multiplexer as a singleton service
            // This allows the application to interact directly with Redis for advanced scenarios
            builder.Services.AddSingleton<IConnectionMultiplexer>(sp =>
                // Establish a connection to the Redis server using the configuration from appsettings.json
                ConnectionMultiplexer.Connect(builder.Configuration["RedisCacheOptions:Configuration"]));

            builder.Services.AddControllers();
            builder.Services.AddEndpointsApiExplorer();
            builder.Services.AddSwaggerGen();

            var app = builder.Build();

            // Configure the HTTP request pipeline.
            if (app.Environment.IsDevelopment())
            {
                app.UseSwagger();
                app.UseSwaggerUI();
            }

            app.UseHttpsRedirection();

            app.UseAuthorization();

            app.MapControllers();

            app.Run();
        }
    }
}
```

Now, run the application and test the functionalities, and it should work as expected.

In the next article, I will discuss the [**Difference Between In-Memory Caching and Distributed Caching in ASP.NET Core**](https://dotnettutorials.net/lesson/difference-between-in-memory-caching-and-distributed-caching-in-asp-netcore/) Applications. In this article, I explain **How to Implement Redis Cache in ASP.NET Core Web API** with Examples. I hope you enjoy this article, How to Implement Redis Cache in ASP.NET Core Web API.

[![dotnettutorials 1280x720](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%221280%22%20height=%22720%22%3E%3C/svg%3E)](https://dotnettutorials.net/pranaya-rout/)

[Dot Net Tutorials](https://dotnettutorials.net/pranaya-rout/)

**About the Author: Pranaya Rout**

Pranaya Rout has published more than 3,000 articles in his 11-year career. Pranaya Rout has very good experience with Microsoft Technologies, Including C#, VB, ASP.NET MVC, ASP.NET Web API, EF, EF Core, ADO.NET, LINQ, SQL Server, MYSQL, Oracle, ASP.NET Core, Cloud Computing, Microservices, Design Patterns and still learning new technologies.

https://www.facebook.com/tutorialsdotnet/http://www.linkedin.com/in/pranaya-routhttps://twitter.com/RoutPranayahttps://www.youtube.com/@DotNetTutorialshttps://wa.me/917021801173https://t.me/dotnettutorials

[Previous Lesson
Customize In-Memory Cache in ASP.NET Core
Lesson 3 within section Caching - ASP.NET Core Web API.](https://dotnettutorials.net/lesson/how-to-create-custom-in-memory-cache-in-asp-net-core-web-api/)

[Next Lesson
In-Memory Caching vs Distributed Caching in ASP.NET Core
Lesson 5 within section Caching - ASP.NET Core Web API.](https://dotnettutorials.net/lesson/difference-between-in-memory-caching-and-distributed-caching-in-asp-netcore/)

### Leave a Reply [Cancel reply](/lesson/how-to-implement-redis-cache-in-asp-net-core-web-api/#respond)

Your email address will not be published. Required fields are marked \*

Comment \* 

Name\*

Email\*

Website

---